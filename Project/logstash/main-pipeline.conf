input {
  tcp {
    port => 5044
    codec => "json_lines"
  }
}

filter {
  # Classification for NGINX Logs
  if [type] == "nginx_log" {
    mutate { add_tag => ["nginx"] }
    http {
      url => "http://localhost:5000/nginx_classify"  # NGINX ML Model API
      http_method => "post"
      format => "json"
      content_type => "application/json"
      body => '{ "log": "%{message}" }'
      target => "nginx_classification"
    }
    mutate {
      add_field => { "classification" => "%{nginx_classification.threat_classification}" }
    }
  }

  # Classification for MySQL Logs
  if [type] == "mysql_log" {
    mutate { add_tag => ["mysql"] }
    http {
      url => "http://localhost:5000/mysql_classify"  # MySQL ML Model API
      http_method => "post"
      format => "json"
      content_type => "application/json"
      body => '{ "log": "%{message}" }'
      target => "mysql_classification"
    }
    mutate {
      add_field => { "classification" => "%{mysql_classification.threat_classification}" }
    }
  }

  # Classification for Firewall Logs
  if [type] == "firewall_log" {
    mutate { add_tag => ["firewall"] }
    http {
      url => "http://localhost:5000/firewall_classify"  # Firewall ML Model API
      http_method => "post"
      format => "json"
      content_type => "application/json"
      body => '{ "log": "%{message}" }'
      target => "firewall_classification"
    }
    mutate {
      add_field => { "classification" => "%{firewall_classification.threat_classification}" }
    }
  }

  # Aggregate Classification Results and Send to NLP
#   if "nginx" in [tags] or "mysql" in [tags] or "firewall" in [tags] {
#     http {
#       url => "http://localhost:6000/nlp_process"  # NLP Service API
#       http_method => "post"
#       format => "json"
#       content_type => "application/json"
#       body => '{
#         "original_log": "%{message}",
#         "log_type": "%{type}",
#         "classification": "%{classification}"
#       }'
#       target => "nlp_result"
#     }

#     # Optionally, merge NLP results back into the event
#     if [nlp_result] {
#       mutate {
#         add_field => { "nlp_analysis" => "%{nlp_result.analysis}" }
#         remove_field => ["nlp_result"]  # Clean up if necessary
#       }
#     }
#   }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["localhost:9200"]
    user => "elastic" 
    password => "CalK2dvNUFdNg-g*hesg" 
    index => "classified-logs-%{+YYYY.MM.dd}"
  }

  # Optional: Output to a file
  file {
    path => "/var/log/classified_logs.log"
    codec => "json_lines"
  }

  # Optional: Output to console for debugging
  stdout { codec => rubydebug }
}
