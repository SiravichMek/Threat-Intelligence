# Input section to receive logs from the sender over TCP
input {
  tcp {
    port => 5045
    codec => line  # Expect logs in line format from the sender
  }
}

# Filter section to process logs and make API calls
filter {
  # Extract event_type and log entry from the incoming line
  grok {
    match => { "message" => "%{DATA:event_type}\|%{GREEDYDATA:log_entry}" }
  }

  # Process NGINX logs
  if [event_type] == "nginx_log" {

    grok {
      match => { 
        "log_entry" => "%{IPORHOST:client_ip}\|%{HTTPDATE:timestamp}\|%{WORD:method}\|%{URIPATHPARAM:request}\|%{NOTSPACE:http_version}\|%{NUMBER:status_code}\|%{NUMBER:response_size}\|%{NOTSPACE:referrer}\|%{GREEDYDATA:user_agent}"
      }
    }
     # %{method} %{request} %{status_code} %{response_size} %{referrer} %{user_agent}
    mutate {
      add_field => {
        "log" => "%{log_entry}"
      }
      remove_field => ["timestamp"]
    }

    # Make API call to predict GET request anomalies
    ruby {
      code => '
        begin
          require "net/http"
          require "uri"
          require "json"
          require "timeout"

          encoded_log = URI.encode_www_form_component(event.get("log"))
          uri = URI.parse("http://127.0.0.1:8080/predict_get?log=#{encoded_log}")

          Timeout.timeout(5) do
            response = Net::HTTP.get_response(uri)
            if response.code == "200"
              result = JSON.parse(response.body)
              event.set("prediction", result["predicted_label"])
            else
              event.tag("api_request_failed")
              event.set("error_response", response.body)
            end
          end
        rescue => e
          event.tag("api_request_failed")
          event.set("error", e.message)
        end
      '
    }
  }

  # Process MySQL logs
  if [event_type] == "mysql_log" {
    grok {
      match => { 
        "log_entry" => "%{TIMESTAMP_ISO8601:timestamp} %{GREEDYDATA:sql_query}" 
      }
    }

    mutate {
      remove_field => ["timestamp"]
      add_field => {
        "log" => "%{log_entry}"
      }
    }

    # Make API call to predict SQL injection or normal queries
    ruby {
      code => '
        begin
          require "net/http"
          require "uri"
          require "json"
          require "timeout"

          encoded_log = URI.encode_www_form_component(event.get("log"))
          uri = URI.parse("http://127.0.0.1:8081/predict?queries=#{encoded_log}")

          Timeout.timeout(5) do
            response = Net::HTTP.get_response(uri)
            if response.code == "200"
              result = JSON.parse(response.body)
              event.set("prediction", result["predicted_label"])
            else
              event.tag("api_request_failed")
              event.set("error_response", response.body)
            end
          end
        rescue => e
          event.tag("api_request_failed")
          event.set("error", e.message)
        end
      '
    }
  }

  # Process Firewall logs (optional, keeping it as is for now)
  if [event_type] == "firewall_log" {
    mutate {
      add_field => { "log" => "%{log_entry}" }
    }

    # Assuming no prediction API for firewall logs, keep it as is for now
  }
}

# Output section to store results and handle failed API requests
output {
  # Save successful predictions to file
  file {
    path => "C:\\Users\\N0trUe\\Desktop\\Log_Data_Test\\api_response.log"
    codec => json_lines
  }

  # Save failed predictions or parsing errors to another file
  if "api_request_failed" in [tags] or "_grokparsefailure" in [tags] {
    file {
      path => "C:\\Users\\N0trUe\\Desktop\\Log_Data_Test\\failed_predictions.log"
      codec => json_lines
    }
  }

  # Debugging output to console
  stdout { codec => rubydebug }
}
